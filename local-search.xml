<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32开发文档——HAL库配置版</title>
    <link href="/2025/04/24/hal_0/"/>
    <url>/2025/04/24/hal_0/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32开发文档——HAL库配置版"><a href="#STM32开发文档——HAL库配置版" class="headerlink" title="STM32开发文档——HAL库配置版"></a>STM32开发文档——HAL库配置版</h1><h2 id="一-时钟配置"><a href="#一-时钟配置" class="headerlink" title="一.时钟配置"></a>一.时钟配置</h2><p><strong>Bypass clock source</strong> 和 <strong>crystal resonator</strong> 都与微控制器的外部时钟源配置有关，但它们之间有一些关键的区别：</p><h3 id="1-Crystal-Resonator（晶体振荡器）："><a href="#1-Crystal-Resonator（晶体振荡器）：" class="headerlink" title="1. Crystal Resonator（晶体振荡器）："></a>1. <strong>Crystal Resonator（晶体振荡器）</strong>：</h3><ul><li><strong>定义</strong>: 这是一个被动组件，通常由石英晶体组成，它在特定频率下自然振荡。这个振荡器本身不会产生时钟信号，但当与微控制器的内部振荡器电路结合使用时，它会通过谐振产生一个稳定的时钟信号。</li><li><strong>使用</strong>: 当你在 STM32CubeMX 中选择使用晶体振荡器（HSE crystal&#x2F;ceramic resonator），微控制器会启用内部的振荡电路，通过与外部晶体配合来生成时钟信号。这个配置方式依赖于微控制器内部的振荡器和外部的晶体振荡器共同工作来产生时钟。</li></ul><h3 id="2-Bypass-Clock-Source（旁路时钟源）："><a href="#2-Bypass-Clock-Source（旁路时钟源）：" class="headerlink" title="2. Bypass Clock Source（旁路时钟源）："></a>2. <strong>Bypass Clock Source（旁路时钟源）</strong>：</h3><ul><li><strong>定义</strong>: Bypass clock source 指的是直接使用外部输入的时钟信号，而不经过微控制器内部的振荡电路。这个外部时钟信号可以来自一个已经产生的高精度时钟源，如晶体振荡器模块、外部时钟发生器、或其他设备提供的时钟信号。</li><li><strong>使用</strong>: 当你选择 Bypass 模式时，微控制器不会使用其内部的振荡电路，也不需要外部的晶体振荡器。相反，它直接接受外部时钟信号输入。因此，时钟信号的生成完全依赖于外部设备或模块，不经过内部处理。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>晶体振荡器</strong>：需要内部振荡电路与外部晶体共同工作来生成时钟信号。这种方式通常用于需要高稳定性时钟的应用。</li><li><strong>旁路时钟源</strong>：直接使用外部提供的时钟信号，而不依赖内部振荡电路。这种方式通常用于有外部高精度时钟源的情况，或在低功耗设计中使用。</li></ul><p><strong>选择使用哪种方式取决于你的应用需求：如果你有一个高精度的外部时钟源，并且不需要微控制器内部的振荡电路参与，你可以选择 Bypass 模式；如果你想利用微控制器内部的振荡器来产生时钟信号，且有一个外部晶体，你可以选择使用晶体振荡器。</strong></p><h2 id="二-GPIO配置"><a href="#二-GPIO配置" class="headerlink" title="二.GPIO配置"></a>二.GPIO配置</h2><p><strong>在 STM32CubeMX 中配置 GPIO（通用输入输出）时，你需要设置多个选项来定义引脚的功能和行为。以下是主要的配置选项及其作用：</strong></p><h3 id="1-GPIO-Mode（模式）"><a href="#1-GPIO-Mode（模式）" class="headerlink" title="1. GPIO Mode（模式）"></a>1. <strong>GPIO Mode（模式）</strong></h3><ul><li><strong>Input（输入）</strong>: 将引脚配置为输入模式。可以选择下拉、上拉、浮空等。</li><li><strong>Output（输出）</strong>: 将引脚配置为输出模式。可以选择推挽输出或开漏输出。</li><li><strong>Alternate Function（备用功能）</strong>: 将引脚配置为特定外设的功能（如 UART、SPI、I2C）。</li><li><strong>Analog（模拟）</strong>: 将引脚配置为模拟模式，用于 ADC、DAC 等。</li></ul><h3 id="2-GPIO-Output-Type（输出类型）"><a href="#2-GPIO-Output-Type（输出类型）" class="headerlink" title="2. GPIO Output Type（输出类型）"></a>2. <strong>GPIO Output Type（输出类型）</strong></h3><ul><li><strong>Push-Pull</strong>: 输出模式中常用的推挽型，适合大多数场景，提供较强的驱动能力。</li><li><strong>Open-Drain</strong>: 开漏型输出，适用于需要多个设备共享同一线的场景，常用于 I2C 总线。</li></ul><h3 id="3-GPIO-Pull-up-Pull-down（上拉-下拉电阻）"><a href="#3-GPIO-Pull-up-Pull-down（上拉-下拉电阻）" class="headerlink" title="3. GPIO Pull-up&#x2F;Pull-down（上拉&#x2F;下拉电阻）"></a>3. <strong>GPIO Pull-up&#x2F;Pull-down（上拉&#x2F;下拉电阻）</strong></h3><ul><li><strong>No Pull-up&#x2F;Pull-down</strong>: 不启用上拉或下拉电阻，适用于没有特殊需求的输入模式。</li><li><strong>Pull-up</strong>: 启用上拉电阻，将引脚默认拉高。</li><li><strong>Pull-down</strong>: 启用下拉电阻，将引脚默认拉低。</li></ul><h3 id="4-GPIO-Speed（速度）"><a href="#4-GPIO-Speed（速度）" class="headerlink" title="4. GPIO Speed（速度）"></a>4. <strong>GPIO Speed（速度）</strong></h3><ul><li><strong>Low Speed</strong>: 低速模式，适用于较低的频率要求。</li><li><strong>Medium Speed</strong>: 中速模式，适用于中等频率要求。</li><li><strong>High Speed</strong>: 高速模式，适用于高频率要求。</li><li><strong>Very High Speed</strong>: 非常高速模式，适用于非常高的频率要求。</li></ul><h3 id="5-GPIO-Alternate-Function（备用功能）"><a href="#5-GPIO-Alternate-Function（备用功能）" class="headerlink" title="5. GPIO Alternate Function（备用功能）"></a>5. <strong>GPIO Alternate Function（备用功能）</strong></h3><ul><li><strong>AF0, AF1, AF2, …</strong>: 选择引脚的具体备用功能。例如，选择引脚的 UART、SPI、I2C 功能等。</li></ul><h3 id="6-GPIO-Output-Level（输出电平）"><a href="#6-GPIO-Output-Level（输出电平）" class="headerlink" title="6. GPIO Output Level（输出电平）"></a>6. <strong>GPIO Output Level（输出电平）</strong></h3><ul><li><strong>High</strong>: 默认输出高电平。</li><li><strong>Low</strong>: 默认输出低电平。</li></ul><h3 id="7-GPIO-Alternate-Function-Selection（备用功能选择）"><a href="#7-GPIO-Alternate-Function-Selection（备用功能选择）" class="headerlink" title="7. GPIO Alternate Function Selection（备用功能选择）"></a>7. <strong>GPIO Alternate Function Selection（备用功能选择）</strong></h3><ul><li><strong>根据选择的备用功能，进一步配置引脚的具体功能。</strong></li></ul><p><strong>通过 STM32CubeMX 配置这些选项，可以精确控制 GPIO 引脚的行为，确保它们在应用中发挥预期作用。</strong></p><h2 id="三-配置GPIO为开漏输出时为什么仍然无法输出高电平"><a href="#三-配置GPIO为开漏输出时为什么仍然无法输出高电平" class="headerlink" title="三.配置GPIO为开漏输出时为什么仍然无法输出高电平?"></a>三.配置GPIO为开漏输出时为什么仍然无法输出高电平?</h2><p><strong>在 GPIO 配置中，如果你将引脚配置为开漏输出并启用上拉电阻，可能会遇到无法输出高电平的问题。这是因为开漏输出的工作原理和设计特点决定了它的行为方式。下面是一些关键点，帮助你理解为什么会这样：</strong></p><h3 id="1-开漏输出（Open-Drain-Output）"><a href="#1-开漏输出（Open-Drain-Output）" class="headerlink" title="1. 开漏输出（Open-Drain Output）"></a>1. <strong>开漏输出（Open-Drain Output）</strong></h3><ul><li><strong>工作原理</strong>: 开漏输出模式的引脚只能拉低电平（即输出逻辑0）。当引脚被设为低电平时，开漏配置会将引脚连接到地（逻辑0），而当引脚被设为高电平时，它实际上会断开，处于高阻状态。</li><li><strong>高电平生成</strong>: 在开漏输出模式下，高电平的生成依赖于外部的上拉电阻。当引脚处于高阻态时，上拉电阻会将引脚拉到高电平（逻辑1）。</li></ul><h3 id="2-启用上拉电阻的作用"><a href="#2-启用上拉电阻的作用" class="headerlink" title="2. 启用上拉电阻的作用"></a>2. <strong>启用上拉电阻的作用</strong></h3><ul><li><strong>内部上拉电阻</strong>: 如果在配置中启用内部上拉电阻，它会将引脚在高阻态时拉到高电平。请注意，这个上拉电阻是微控制器内部的电阻，可能值较大，具体取决于微控制器的设计。</li><li><strong>外部上拉电阻</strong>: 有时需要额外的外部上拉电阻，以确保上拉效果足够强，以应对较高的电流需求或更快的响应速度。外部上拉电阻通常会有更低的阻值（例如 10kΩ 或 4.7kΩ），与内部上拉电阻相比。</li></ul><h3 id="3-可能的问题"><a href="#3-可能的问题" class="headerlink" title="3. 可能的问题"></a>3. <strong>可能的问题</strong></h3><ul><li><strong>电阻值不足</strong>: 如果内部上拉电阻的值太高，可能无法提供足够的电流来维持高电平。在这种情况下，可能需要添加外部上拉电阻。</li><li><strong>引脚未正确配置</strong>: 确保在配置中选择了正确的引脚模式。如果引脚配置有误（例如，不是开漏模式），则无法正确输出。</li><li><strong>电源问题</strong>: 确保电源电压正常，如果电源电压过低，可能会影响上拉电阻的工作效果。</li></ul><h3 id="4-解决方法"><a href="#4-解决方法" class="headerlink" title="4. 解决方法"></a>4. <strong>解决方法</strong></h3><ol><li><strong>检查引脚配置</strong>: 确保在 STM32CubeMX 中正确配置了引脚的开漏模式和上拉电阻。</li><li><strong>添加外部上拉电阻</strong>: 在引脚和电源之间添加一个适当阻值的外部上拉电阻（如 10kΩ），以确保能可靠地输出高电平。</li><li><strong>验证电源电压</strong>: 确保微控制器和电路的电源电压稳定，并符合设计要求。</li></ol><p><strong>通过这些步骤，你应该能够解决配置开漏输出引脚时无法输出高电平的问题。</strong></p><h2 id="四-外部中断"><a href="#四-外部中断" class="headerlink" title="四.外部中断"></a>四.外部中断</h2><p><strong>CubeMX 是一个图形化工具，用于配置 STM32 微控制器的外设和中断，包括外部中断（External Interrupt）。在 CubeMX 中，外部中断的配置选项可以包括以下几项，每一项的含义如下：</strong></p><ol><li><strong>GPIO Pin Selection（GPIO 引脚选择）</strong>：<ul><li><strong>用于选择哪个 GPIO 引脚将被配置为外部中断源。每个 GPIO 引脚都有可能被配置为外部中断输入。</strong></li></ul></li><li><strong>Mode（模式）</strong>：<ul><li><strong>External Interrupt Mode</strong>: 配置引脚为外部中断模式，触发中断。</li><li><strong>Event Mode</strong>: 配置引脚生成事件，但不触发中断。</li></ul></li><li><strong>Trigger Selection（触发选择）</strong>：<ul><li><strong>Rising Edge</strong>: 在上升沿（电压从低到高）触发中断。</li><li><strong>Falling Edge</strong>: 在下降沿（电压从高到低）触发中断。</li><li><strong>Rising and Falling Edge</strong>: 在上升沿和下降沿均触发中断。</li></ul></li><li><strong>Pull-up&#x2F;Pull-down（上拉&#x2F;下拉）</strong>：<ul><li><strong>No Pull</strong>: 不使用内部上拉或下拉电阻。</li><li><strong>Pull-up</strong>: 使用内部上拉电阻，将引脚默认拉高。</li><li><strong>Pull-down</strong>: 使用内部下拉电阻，将引脚默认拉低。</li></ul></li><li><strong>Priority（优先级）</strong>：<ul><li><strong>设置中断的优先级。优先级越高（数值越低），中断处理的优先级越高。</strong></li></ul></li><li><strong>Sub-Priority（子优先级）</strong>：<ul><li><strong>在相同的优先级下，用于进一步区分中断的先后顺序。</strong></li></ul></li><li><strong>Enable&#x2F;Disable（启用&#x2F;禁用）</strong>：<ul><li><strong>启用或禁用相应的外部中断。</strong></li></ul></li></ol><p><strong>在 CubeMX 的图形界面中，这些选项通常会通过下拉菜单、复选框或其他控件来设置。一旦配置完成，CubeMX 会生成相应的初始化代码，用于在 STM32 微控制器上实现这些配置。</strong></p><p><strong>通过正确配置这些选项，用户可以控制外部中断的行为，包括哪个引脚触发中断、在什么条件下触发、以及中断的优先级等。</strong></p><h2 id="五-那么只触发事件而不触发中断有什么用"><a href="#五-那么只触发事件而不触发中断有什么用" class="headerlink" title="五.那么只触发事件而不触发中断有什么用?"></a>五.那么只触发事件而不触发中断有什么用?</h2><p><strong>只触发事件而不触发中断的机制在许多应用场景中都能发挥重要作用，尤其是在需要高效处理、减少开销或避免中断风暴的情况下。以下是一些具体的应用场景：</strong></p><ol><li><strong>轮询机制</strong>：<ul><li><strong>在某些实时系统中，轮询机制比中断机制更适合，因为它可以减少中断处理的复杂性和上下文切换的开销。</strong></li><li><strong>例如，在一个嵌入式系统中，主循环可以定期检查某些事件标志，而不是依赖中断来处理事件。</strong></li></ul></li><li><strong>低优先级任务处理</strong>：<ul><li><strong>对于一些低优先级的任务，只需在空闲时处理即可。触发事件标志而不产生中断可以确保这些任务在系统资源允许的情况下得到处理，而不会打扰高优先级任务。</strong></li><li><strong>比如，后台数据收集或日志记录任务可以通过事件标志来触发，而不是通过中断。</strong></li></ul></li><li><strong>批处理操作</strong>：<ul><li><strong>某些应用需要在一段时间内收集多个事件，然后一次性处理所有事件。使用事件标志可以累积这些事件，避免频繁的中断。</strong></li><li><strong>例如，网络数据包的批量处理可以通过事件标志来触发批处理操作，从而提高效率。</strong></li></ul></li><li><strong>减少中断风暴</strong>：<ul><li><strong>在高负载系统中，频繁的中断可能导致中断风暴，影响系统性能。使用事件标志可以减少中断的频率，从而提高系统稳定性。</strong></li><li><strong>比如，在网络服务器中，可以使用事件标志来累积请求，然后在合适的时机批量处理。</strong></li></ul></li><li><strong>状态监控</strong>：<ul><li><strong>在状态监控系统中，某些状态变化可能不需要立即处理，只需记录事件并在适当时机处理即可。事件标志可以记录这些状态变化，而不立即触发中断。</strong></li><li><strong>例如，温度传感器可以通过事件标志记录温度变化，而不需要每次变化都触发中断。</strong></li></ul></li><li><strong>资源节约</strong>：<ul><li><strong>在资源受限的系统中，减少中断处理的开销可以节约宝贵的计算资源。通过事件标志，可以在资源允许的情况下处理事件，而不是立即中断当前任务。</strong></li><li><strong>比如，在低功耗设备中，可以通过事件标志来减少功耗，使系统在处理事件时更加高效。</strong></li></ul></li></ol><p><strong>这些场景展示了只触发事件标志而不触发中断在不同应用中的重要性和优越性。通过这种机制，可以更好地平衡系统性能、资源利用和响应时间。</strong></p><h2 id="六-定时器配置"><a href="#六-定时器配置" class="headerlink" title="六.定时器配置"></a>六.定时器配置</h2><p><strong>在CubeMX（STM32CubeMX）中配置定时器时，你可以选择和设置多个配置选项。以下是一些主要配置选项及其含义：</strong></p><ol><li><strong>Mode（模式）</strong>：<ul><li><strong>Basic Timer</strong>：基础定时器模式，适用于计时和简单的事件生成。</li><li><strong>PWM Generation</strong>：用于生成PWM信号。</li><li><strong>Input Capture</strong>：用于捕获外部信号的时间戳。</li><li><strong>Output Compare</strong>：用于生成预定的信号，通常用于定时任务。</li><li><strong>Encoder Interface</strong>：用于解码旋转编码器信号。</li><li><strong>One Pulse Mode</strong>：生成单脉冲输出。</li></ul></li><li><strong>Prescaler（预分频器）</strong>：<ul><li><strong>Prescaler</strong>：定时器时钟的预分频器设置，可以将定时器时钟频率降低，影响计数器的计数速度。设置预分频器可以延长定时器溢出时间或提高计数精度。</li></ul></li><li><strong>Counter Mode（计数器模式）</strong>：<ul><li><strong>Up</strong>：计数器向上计数。</li><li><strong>Down</strong>：计数器向下计数。</li><li><strong>Up&#x2F;Down</strong>：计数器同时向上和向下计数。适用于某些应用需要对称计数的情况。</li></ul></li><li><strong>Period (Auto-Reload Register, ARR)（周期）</strong>：<ul><li><strong>Period</strong>：定时器的自动重载寄存器值。决定了计数器从0计数到该值的周期。定时器到达该值时会产生溢出事件。</li></ul></li><li><strong>Pulse (Capture&#x2F;Compare Register, CCR)（脉冲宽度）</strong>：<ul><li><strong>Pulse</strong>：在PWM模式下设置PWM脉冲宽度。它决定了PWM信号的占空比。</li></ul></li><li><strong>Clock Division（时钟分频）</strong>：<ul><li><strong>No Division</strong>：不分频。</li><li><strong>1</strong>：时钟分频系数为1，时钟频率不变。</li><li><strong>2</strong>：时钟分频系数为2，时钟频率减半。</li><li><strong>4</strong>：时钟分频系数为4，时钟频率减少四分之一。</li></ul></li><li><strong>Interrupts（中断）</strong>：<ul><li><strong>Update Interrupt</strong>：定时器溢出（更新）中断。</li><li><strong>Capture&#x2F;Compare Interrupt</strong>：捕获或比较中断。</li><li><strong>Trigger Interrupt</strong>：触发事件中断。</li><li><strong>Break Interrupt</strong>：断路中断（用于控制PWM输出的强制停止）。</li></ul></li><li><strong>DMA Requests（DMA请求）</strong>：<ul><li><strong>DMA Requests</strong>：定时器事件可以触发DMA传输。可以选择DMA请求以便将数据从外设传输到内存，或从内存传输到外设。</li></ul></li><li><strong>Clock Source（时钟源）</strong>：<ul><li><strong>Internal Clock</strong>：使用内部时钟源（如系统时钟）。</li><li><strong>External Clock</strong>：使用外部时钟源（如外部晶振或外部信号）。</li></ul></li></ol><p><strong>这些选项通过CubeMX的图形界面进行配置，使得你可以直观地设置定时器的功能和参数，生成的代码将包括相应的初始化函数和配置代码，帮助你快速启动定时器功能。</strong></p><p><img src="file:///C:/Users/23343/AppData/Roaming/Typora/typora-user-images/image-20240903162930222.png?lastModify=1745432490" alt="image-20240903162930222"></p><p><strong>以上是TRGO触发的相关连接表格，根据这个表格可以实现定时器级联的功能</strong></p><h2 id="七-定时器的从模式有哪些配置，都是什么意思？"><a href="#七-定时器的从模式有哪些配置，都是什么意思？" class="headerlink" title="七.定时器的从模式有哪些配置，都是什么意思？"></a>七.定时器的从模式有哪些配置，都是什么意思？</h2><p><strong>在 STM32 的定时器配置中，”从模式”通常涉及到将定时器设置为一个特定的工作模式，以便它可以在主定时器的控制下同步或触发其他定时器或外设。以下是定时器的一些常见从模式配置：</strong></p><h3 id="1-定时器的从模式配置"><a href="#1-定时器的从模式配置" class="headerlink" title="1. 定时器的从模式配置"></a>1. 定时器的从模式配置</h3><h4 id="1-1-从定时器同步"><a href="#1-1-从定时器同步" class="headerlink" title="1.1. 从定时器同步"></a><strong>1.1. 从定时器同步</strong></h4><ul><li><strong>Master&#x2F;Slave Mode</strong>：<ul><li><strong>Master</strong>：定时器作为主定时器，控制从定时器的启动、停止或触发。</li><li><strong>Slave</strong>：定时器作为从定时器，通过主定时器的信号来同步。</li></ul></li><li><strong>Slave Mode Options</strong>：<ul><li><strong>Trigger Mode</strong>：从定时器根据主定时器的触发信号（如更新事件、输入捕获等）进行同步。</li><li><strong>Reset Mode</strong>：从定时器在主定时器的事件发生时被复位。</li><li><strong>Gated Mode</strong>：从定时器的计数仅在主定时器处于高电平时进行。</li></ul></li><li><strong>Trigger Source</strong>：<ul><li><strong>选择触发源，例如主定时器的更新事件、外部信号等，用于从定时器的触发。</strong></li></ul></li></ul><h4 id="1-2-从定时器输出"><a href="#1-2-从定时器输出" class="headerlink" title="1.2. 从定时器输出"></a><strong>1.2. 从定时器输出</strong></h4><ul><li><strong>Output Compare Mode</strong>：<ul><li><strong>PWM Mode</strong>：用于生成脉宽调制信号，可以通过主定时器控制从定时器的 PWM 输出。</li><li><strong>Toggle Mode</strong>：定时器到达比较值时，输出引脚状态翻转。</li></ul></li><li><strong>Encoder Interface Mode</strong>：<ul><li><strong>如果你使用定时器作为编码器接口，可以配置定时器从模式来同步读取编码器数据。</strong></li></ul></li></ul><h3 id="2-配置实例"><a href="#2-配置实例" class="headerlink" title="2. 配置实例"></a>2. <strong>配置实例</strong></h3><p><strong>假设你想将一个定时器（Timer 2）配置为主定时器，并使另一个定时器（Timer 3）作为从定时器，通过 Timer 2 的更新事件来触发 Timer 3：</strong></p><ol><li><strong>配置 Timer 2</strong> 为主定时器，并设置其工作模式（例如 PWM）。</li><li><strong>配置 Timer 3</strong> 为从定时器，设置其为 <strong>Trigger Mode</strong>，触发源选择 Timer 2 的更新事件。</li></ol><h3 id="示例代码（伪代码）"><a href="#示例代码（伪代码）" class="headerlink" title="示例代码（伪代码）"></a>示例代码（伪代码）</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coq">// Timer <span class="hljs-number">2</span> configuration <span class="hljs-built_in">as</span> Master<br>TIM2-&gt;SMCR |<span class="hljs-type">= TIM_SMCR_MSTR</span>;   // Enable Master <span class="hljs-keyword">Mode</span><br>TIM2-&gt;CR1 |<span class="hljs-type">= TIM_CR1_CEN</span>;      // Enable Timer <span class="hljs-number">2</span><br><br>// Timer <span class="hljs-number">3</span> configuration <span class="hljs-built_in">as</span> Slave<br>TIM3-&gt;SMCR |<span class="hljs-type">= TIM_SMCR_SMS_0</span>;  // Select Slave <span class="hljs-keyword">Mode</span><br>TIM3-&gt;SMCR |<span class="hljs-type">= TIM_SMCR_TS_1</span>;   // Trigger Source is Timer <span class="hljs-number">2</span><br>TIM3-&gt;CR1 |<span class="hljs-type">= TIM_CR1_CEN</span>;      // Enable Timer <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>以上示例只是一个简化的伪代码，实际配置需要参考具体的 STM32 数据手册和 HAL 库文档。</strong></p><h2 id="八-ADC单次扫描和非扫描模式的区别"><a href="#八-ADC单次扫描和非扫描模式的区别" class="headerlink" title="八.ADC单次扫描和非扫描模式的区别"></a>八.ADC单次扫描和非扫描模式的区别</h2><p><strong>ADC（模数转换器）在微控制器和其他嵌入式系统中广泛使用，用于将模拟信号转换为数字信号。ADC通常有多种工作模式，其中单次扫描和非扫描模式是两个常见的模式。以下是这两种模式的区别：</strong></p><h3 id="单次扫描模式"><a href="#单次扫描模式" class="headerlink" title="单次扫描模式"></a>单次扫描模式</h3><p><strong>单次扫描模式（Single Scan Mode）指的是ADC一次性扫描一组预定义的多个通道，然后停止。具体工作流程如下：</strong></p><ol><li><strong>配置通道</strong>：用户预先配置好需要扫描的多个ADC通道。</li><li><strong>启动转换</strong>：启动转换后，ADC会按顺序逐一转换预定义的所有通道。</li><li><strong>转换完成</strong>：所有通道转换完成后，ADC停止工作，等待下一次启动命令。</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>效率高</strong>：适合需要同时读取多个模拟信号的应用，一次启动即可读取所有配置的通道。</li><li><strong>同步性好</strong>：多个通道的数据几乎同时获取，便于比较和同步处理。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>复杂度高</strong>：需要预先配置多个通道，设置较为复杂。</li><li><strong>时间较长</strong>：一次性转换多个通道可能会比单通道转换花费更多时间。</li></ul><h3 id="非扫描模式"><a href="#非扫描模式" class="headerlink" title="非扫描模式"></a>非扫描模式</h3><p><strong>非扫描模式（Non-Scan Mode）指的是ADC每次只转换一个指定的通道。具体工作流程如下：</strong></p><ol><li><strong>选择通道</strong>：用户每次选择一个要转换的ADC通道。</li><li><strong>启动转换</strong>：启动转换后，ADC仅对选定的通道进行转换。</li><li><strong>读取结果</strong>：转换完成后，用户读取该通道的转换结果。</li></ol><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>简单易用</strong>：配置和使用较为简单，每次只需处理一个通道。</li><li><strong>快速响应</strong>：适合对单个通道的快速、多次读取。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>效率低</strong>：如果需要读取多个通道，需要多次启动转换，效率较低。</li><li><strong>同步性差</strong>：多个通道之间的数据获取不同步，不适合需要同时读取多个信号的应用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>选择单次扫描模式还是非扫描模式，主要取决于应用场景的具体需求。如果需要同时读取和处理多个模拟信号，单次扫描模式是更好的选择。而如果主要关注单个信号的快速响应和处理，非扫描模式则更为适合。</strong></p><h2 id="九-ADC扫描模式和非扫描模式的区别"><a href="#九-ADC扫描模式和非扫描模式的区别" class="headerlink" title="九.ADC扫描模式和非扫描模式的区别"></a>九.ADC扫描模式和非扫描模式的区别</h2><p><strong>ADC（模数转换器）的扫描模式和非扫描模式是两种不同的工作模式，适用于不同的应用场景。以下是它们的具体区别：</strong></p><h3 id="扫描模式（Scan-Mode）"><a href="#扫描模式（Scan-Mode）" class="headerlink" title="扫描模式（Scan Mode）"></a>扫描模式（Scan Mode）</h3><p><strong>扫描模式允许ADC在一次启动后自动依次转换多个通道，适用于需要采集多个模拟信号的应用场景。</strong></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li><strong>通道配置</strong>：用户可以预先配置多个ADC通道。</li><li><strong>启动转换</strong>：ADC启动后，自动按顺序对配置的所有通道依次进行转换。</li><li><strong>自动循环</strong>：在转换完成所有通道后，ADC会停止或者重新开始（如果设置为循环扫描）。</li><li><strong>数据读取</strong>：转换完成后，可以读取各个通道的数字值，通常以FIFO（先进先出）队列的方式存储转换结果。</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>多通道转换</strong>：一次启动就可以依次转换多个通道。</li><li><strong>适合同步采集</strong>：同时采集多个模拟信号，保证数据的相对同步性。</li><li><strong>复杂配置</strong>：需要用户预先配置好多个通道，适合较复杂的应用。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>适用于需要多信号同时处理的场景，如电机控制、传感器数据采集等。</strong></li><li><strong>例如：采集电压、电流、温度等多个信号。</strong></li></ul><h3 id="非扫描模式（Non-Scan-Mode）"><a href="#非扫描模式（Non-Scan-Mode）" class="headerlink" title="非扫描模式（Non-Scan Mode）"></a>非扫描模式（Non-Scan Mode）</h3><p><strong>非扫描模式是指ADC每次只转换一个指定的通道，适用于需要单个通道频繁采集的场景。</strong></p><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li><strong>选择通道</strong>：每次转换前，用户需要选择要转换的ADC通道。</li><li><strong>启动转换</strong>：启动ADC后，ADC只对选定的单个通道进行转换。</li><li><strong>读取结果</strong>：转换完成后，用户可以读取该通道的数字值。</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>单通道转换</strong>：每次只转换一个通道，转换效率高。</li><li><strong>简单易用</strong>：无需配置多个通道，操作简单。</li><li><strong>独立采样</strong>：通道转换相互独立，适合需要对单个信号高频采样的场景。</li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>适合单信号频繁采集，如电压测量、温度测量等。</strong></li><li><strong>例如：只需要采集一个传感器的数据。</strong></li></ul><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><table><thead><tr><th><strong>区别点</strong></th><th><strong>扫描模式</strong></th><th><strong>非扫描模式</strong></th></tr></thead><tbody><tr><td><strong>通道数量</strong></td><td><strong>一次转换多个通道</strong></td><td><strong>每次转换一个通道</strong></td></tr><tr><td><strong>启动方式</strong></td><td><strong>一次启动即可依次转换多个通道</strong></td><td><strong>每次转换一个通道前需要启动一次</strong></td></tr><tr><td><strong>操作复杂度</strong></td><td><strong>较复杂，需配置多个通道</strong></td><td><strong>操作简单，只需选择单通道</strong></td></tr><tr><td><strong>应用场景</strong></td><td><strong>同时处理多个信号的应用，如传感器阵列</strong></td><td><strong>单信号采集应用，如单一传感器</strong></td></tr><tr><td><strong>同步性</strong></td><td><strong>各通道转换相对同步</strong></td><td><strong>不同通道之间无法保证同步</strong></td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>扫描模式</strong>更适合需要采集多个模拟信号的应用场景，一次启动后可以自动转换多个通道。</li><li><strong>非扫描模式</strong>则适合单通道的高频采集和处理，每次只能转换一个通道。</li></ul><p><strong>根据应用需求选择合适的模式可以提高ADC转换的效率和精度。</strong></p><h2 id="十-如何使用ADC的非扫描模式实现多通道ADC的读取"><a href="#十-如何使用ADC的非扫描模式实现多通道ADC的读取" class="headerlink" title="十.如何使用ADC的非扫描模式实现多通道ADC的读取"></a>十.如何使用ADC的非扫描模式实现多通道ADC的读取</h2><p><strong>在使用ADC的非扫描模式实现多通道的读取时，尽管非扫描模式一次只能转换一个通道，但可以通过以下步骤轮流选择通道并读取数据，实现多个通道的ADC数据采集。该方法适合需要频繁采集多个模拟信号，但不需要在同一时间点对多个通道同时转换的应用。</strong></p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p><strong>初始化ADC</strong></p><ul><li><strong>首先，初始化ADC模块，将其配置为非扫描模式。非扫描模式意味着每次只能对一个通道进行转换。</strong></li></ul></li><li><p><strong>配置多个ADC通道</strong></p><ul><li><strong>在非扫描模式下，ADC不会自动轮询多个通道，所以需要手动配置每个通道。一般情况下，通过修改ADC的通道选择寄存器，切换到需要采集的通道。</strong></li><li><strong>通常在每次读取前，选择所需的ADC通道。这个过程可以通过编程来实现自动轮询。</strong></li></ul></li><li><p><strong>手动切换通道并启动转换</strong></p><ul><li><strong>轮流选择每个需要采集的通道，启动ADC转换，并等待转换完成。</strong></li><li><strong>每次选择通道时，可以通过编写代码来手动指定当前要采集的通道，启动ADC转换后，读取该通道的转换结果。</strong></li><li><strong>伪代码如下：</strong></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; num_of_channels; i++) &#123;<br>    <span class="hljs-comment">// 选择当前通道 i</span><br>    ADC_SelectChannel(i);<br><br>    <span class="hljs-comment">// 启动ADC转换</span><br>    ADC_StartConversion();<br><br>    <span class="hljs-comment">// 等待转换完成</span><br>    <span class="hljs-keyword">while</span> (!ADC_ConversionComplete());<br><br>    <span class="hljs-comment">// 读取转换结果</span><br>    results[i] = ADC_GetConversionResult();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>读取转换结果</strong></p><ul><li><strong>当转换完成时，读取每个通道的转换结果并存储到数组或变量中。</strong></li><li><strong>每次读取完成后，可以处理数据，或者继续进行下一个通道的读取。</strong></li></ul></li><li><p><strong>重复转换</strong></p><ul><li><strong>可以在一个定时器中断或循环中重复上述步骤，以不断获取多个通道的数据。</strong></li></ul></li></ol><h3 id="示例代码（基于伪代码结构）"><a href="#示例代码（基于伪代码结构）" class="headerlink" title="示例代码（基于伪代码结构）"></a>示例代码（基于伪代码结构）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_OF_CHANNELS 3  <span class="hljs-comment">// 需要读取的通道数</span></span><br><span class="hljs-type">int</span> results[NUM_OF_CHANNELS];  <span class="hljs-comment">// 存储ADC转换结果</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADC_MultiChannel_Read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_OF_CHANNELS; i++) &#123;<br>        <span class="hljs-comment">// 选择ADC通道</span><br>        <span class="hljs-built_in">ADC_SelectChannel</span>(i);<br><br>        <span class="hljs-comment">// 启动ADC转换</span><br>        <span class="hljs-built_in">ADC_StartConversion</span>();<br><br>        <span class="hljs-comment">// 等待转换完成</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">ADC_ConversionComplete</span>());<br><br>        <span class="hljs-comment">// 获取ADC转换结果</span><br>        results[i] = <span class="hljs-built_in">ADC_GetConversionResult</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ol><li><strong>初始化</strong>：初始化ADC并配置为非扫描模式，同时配置时钟、参考电压等相关参数。</li><li><strong>轮询通道</strong>：每次手动选择一个通道，启动ADC转换。</li><li><strong>读取结果</strong>：当转换完成后，读取对应通道的ADC结果，并保存。</li><li><strong>多次轮询</strong>：重复选择其他通道并读取数据，实现多通道读取。</li></ol><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>适合少量多通道读取</strong>：例如监测电压、温度传感器等。</li><li><strong>可以与定时器结合</strong>：通过定时器实现定时采样，实现周期性采集多个通道的模拟信号。</li></ul><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>操作简单</strong>：无需复杂的扫描模式配置，直接手动选择通道。</li><li><strong>灵活性高</strong>：可以根据需要手动控制采样顺序和频率。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>效率较低</strong>：每次只能采集一个通道，多个通道采集需要轮询，延迟可能增加。</li><li><strong>同步性差</strong>：各通道的采样时间存在差异，不适合需要多通道严格同步的场合。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>通过在非扫描模式下手动切换通道并启动转换，可以实现多通道的ADC读取。该方法简单灵活，适用于少量通道的采集任务，不适合需要高效同时采集大量通道的场景。</strong></p><h2 id="十一-ADC规则组和注入组的区别-注入组和规则组的通道数的区别"><a href="#十一-ADC规则组和注入组的区别-注入组和规则组的通道数的区别" class="headerlink" title="十一.ADC规则组和注入组的区别&amp;&amp;注入组和规则组的通道数的区别"></a>十一.ADC规则组和注入组的区别&amp;&amp;注入组和规则组的通道数的区别</h2><p><strong>ADC（模数转换器）在许多微控制器中都有规则组和注入组两种转换机制，这两种机制适用于不同的应用场景。以下是它们的主要区别：</strong></p><h3 id="规则组（Regular-Group）"><a href="#规则组（Regular-Group）" class="headerlink" title="规则组（Regular Group）"></a>规则组（Regular Group）</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>常规用途</strong>：规则组通常用于常规的ADC转换任务。</li><li><strong>转换顺序</strong>：按照预定的顺序依次进行通道转换。</li><li><strong>触发源</strong>：可以由软件触发或者定时器等硬件触发源触发。</li><li><strong>优先级</strong>：规则组的优先级通常低于注入组。</li><li><strong>数据读取</strong>：转换结果通常存储在一个规则的数据寄存器中，按顺序读取。</li></ol><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>周期性的数据采集，比如传感器数据的定时采集。</strong></li><li><strong>通常用于需要大批量数据但时间敏感性较低的任务。</strong></li></ul><h3 id="注入组（Injected-Group）"><a href="#注入组（Injected-Group）" class="headerlink" title="注入组（Injected Group）"></a>注入组（Injected Group）</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>高优先级</strong>：注入组通常具有更高的优先级，可以中断规则组的转换任务。</li><li><strong>转换时机</strong>：通常用于需要在特定时间点或事件发生时进行的高优先级转换。</li><li><strong>触发源</strong>：可以由外部事件、定时器或者软件触发。</li><li><strong>转换灵活性</strong>：可以在规则组转换过程中插入注入组的转换。</li><li><strong>数据读取</strong>：转换结果通常存储在单独的注入数据寄存器中，便于区分和读取。</li></ol><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>需要在特定事件发生时快速响应并进行数据采集的应用。</strong></li><li><strong>实时控制系统中需要高优先级处理的数据采集，比如紧急状态监测。</strong></li></ul><h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><table><thead><tr><th><strong>区别点</strong></th><th><strong>规则组（Regular Group）</strong></th><th><strong>注入组（Injected Group）</strong></th></tr></thead><tbody><tr><td><strong>优先级</strong></td><td><strong>相对较低</strong></td><td><strong>相对较高</strong></td></tr><tr><td><strong>触发源</strong></td><td><strong>软件或定时器触发</strong></td><td><strong>外部事件、定时器或软件触发</strong></td></tr><tr><td><strong>转换顺序</strong></td><td><strong>按预定顺序依次转换</strong></td><td><strong>可以在任何时间点或事件插入转换</strong></td></tr><tr><td><strong>应用场景</strong></td><td><strong>周期性数据采集，时间敏感性较低</strong></td><td><strong>事件驱动的数据采集，需快速响应</strong></td></tr><tr><td><strong>数据寄存器</strong></td><td><strong>规则数据寄存器</strong></td><td><strong>单独的注入数据寄存器</strong></td></tr><tr><td><strong>转换中断</strong></td><td><strong>不会中断注入组的转换</strong></td><td><strong>可以中断规则组的转换</strong></td></tr></tbody></table><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>规则组</strong>（Regular Group）适用于常规的、周期性的ADC数据采集任务，优先级较低。</li><li><strong>注入组</strong>（Injected Group）适用于需要在特定事件发生时快速响应的数据采集任务，优先级较高。</li></ul><p><strong>根据具体的应用需求，选择使用规则组还是注入组可以更有效地管理ADC资源，提高系统的响应速度和数据处理效率。</strong></p><p><strong>在ADC中，注入组和规则组在通道数方面有一些区别，具体取决于微控制器型号和ADC的设计。以下是两者在通道数量上的区别：</strong></p><h3 id="规则组（Regular-Group）-1"><a href="#规则组（Regular-Group）-1" class="headerlink" title="规则组（Regular Group）"></a>规则组（Regular Group）</h3><ol><li><strong>通道数量</strong>：规则组通常可以配置多个通道进行转换，具体数量取决于ADC硬件的设计。例如，某些微控制器的ADC可能允许规则组配置8到16个通道。</li><li><strong>通道配置</strong>：用户可以根据需要选择多个通道进行依次扫描转换。所有被配置的通道将按照预先设定的顺序进行转换。</li><li><strong>转换顺序</strong>：规则组会按照用户配置的通道顺序依次转换每一个通道。</li></ol><h3 id="注入组（Injected-Group）-1"><a href="#注入组（Injected-Group）-1" class="headerlink" title="注入组（Injected Group）"></a>注入组（Injected Group）</h3><ol><li><strong>通道数量</strong>：注入组通常允许配置的通道数量较少。常见的情况是注入组支持1到4个通道，具体的数量也取决于微控制器的型号。</li><li><strong>转换灵活性</strong>：由于注入组通常用于高优先级的突发事件处理，因此允许的通道数量比规则组少，但转换的时机更加灵活。</li><li><strong>独立通道配置</strong>：注入组的通道独立于规则组，用户可以单独为注入组选择特定的通道。</li></ol><h3 id="通道数的比较"><a href="#通道数的比较" class="headerlink" title="通道数的比较"></a>通道数的比较</h3><table><thead><tr><th><strong>区别点</strong></th><th><strong>规则组（Regular Group）</strong></th><th><strong>注入组（Injected Group）</strong></th></tr></thead><tbody><tr><td><strong>通道数量</strong></td><td><strong>通常允许配置多个通道（8到16个不等）</strong></td><td><strong>通常允许配置较少的通道（1到4个不等）</strong></td></tr><tr><td><strong>通道用途</strong></td><td><strong>常规数据采集，周期性任务</strong></td><td><strong>高优先级数据采集，事件驱动</strong></td></tr><tr><td><strong>配置方式</strong></td><td><strong>可以选择多个通道按顺序转换</strong></td><td><strong>独立于规则组，配置少量通道</strong></td></tr></tbody></table><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>规则组</strong>可以配置较多的通道数，适合常规的多通道数据采集任务。</li><li><strong>注入组</strong>通道数量较少，适合需要快速响应的少量高优先级信号采集。</li></ul><p><strong>在实际应用中，如果需要采集大量的模拟信号，可以使用规则组；如果需要对特定事件进行快速响应，注入组更合适。</strong></p><h2 id="十二-DMA转运的作用是什么？为什么需要地址自增"><a href="#十二-DMA转运的作用是什么？为什么需要地址自增" class="headerlink" title="十二.DMA转运的作用是什么？为什么需要地址自增"></a>十二.DMA转运的作用是什么？为什么需要地址自增</h2><p><strong>DMA（Direct Memory Access，直接内存访问）是一种计算机系统功能，允许外设或硬件模块直接访问系统内存，而不需要CPU的干预。这种机制在数据传输过程中显著提高了系统效率和性能。</strong></p><h3 id="DMA的作用"><a href="#DMA的作用" class="headerlink" title="DMA的作用"></a>DMA的作用</h3><ol><li><strong>减少CPU负载</strong>：DMA可以在不占用CPU资源的情况下进行数据传输，使得CPU可以处理其他任务，提高系统整体性能。</li><li><strong>高效数据传输</strong>：DMA能够以更高的速度和效率传输数据，因为它可以绕过CPU直接在内存与外设之间传输数据。</li><li><strong>实时性</strong>：在实时系统中，DMA可以确保数据传输的及时性，减少数据传输延迟。</li></ol><h3 id="DMA的工作原理"><a href="#DMA的工作原理" class="headerlink" title="DMA的工作原理"></a>DMA的工作原理</h3><ol><li><strong>配置DMA控制器</strong>：设置源地址、目标地址、数据传输大小和传输模式等参数。</li><li><strong>启动DMA传输</strong>：配置完成后，启动DMA传输。</li><li><strong>数据传输</strong>：DMA控制器根据配置的参数，自动完成数据从源地址到目标地址的传输。</li><li><strong>传输完成</strong>：传输完成后，DMA控制器可以产生中断通知CPU，或者由CPU自行查询传输状态。</li></ol><h3 id="地址自增的重要性"><a href="#地址自增的重要性" class="headerlink" title="地址自增的重要性"></a>地址自增的重要性</h3><p><strong>在很多情况下，DMA需要连续传输一块内存中的数据到另一块内存或者外设中，这时地址自增功能非常关键。以下是地址自增的主要作用和原因：</strong></p><ol><li><strong>连续数据传输</strong>：在传输连续数据块时，每次传输完成后，源地址和目标地址需要自动更新到下一个数据单元的位置。例如，假设需要传输一个数组的数据，从源地址开始，每传输一个元素，地址需要增加，指向下一个元素。</li><li><strong>简化编程</strong>：地址自增功能简化了编程复杂度。无需手动更新每次传输的地址，DMA控制器自动处理地址的递增，减少了编程的复杂性和错误的可能性。</li><li><strong>提高效率</strong>：自动地址自增可以显著提高数据传输效率。CPU只需一次配置DMA控制器，DMA控制器就可以自动完成整个数据块的传输，无需CPU干预。</li><li><strong>支持多种传输模式</strong>：<ul><li><strong>内存到内存</strong>：在内存之间传输数据时，源地址和目标地址都需要自增，以便逐个传输数据。</li><li><strong>外设到内存</strong>：如ADC数据采集，ADC将数据写入内存，目标地址需要自增，以便将连续的数据写入内存的不同位置。</li><li><strong>内存到外设</strong>：如DAC数据输出，从内存读取数据并输出到DAC，源地址需要自增，以便读取内存中连续的数据。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>假设我们有一个ADC模块，通过DMA将采集到的模拟信号数据存储到内存中的一个数组中。每次ADC转换完成后，DMA会自动将数据传输到内存数组的下一个位置。</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> ADC_BUFFER_SIZE <span class="hljs-number">100</span><br>uint16_t adc_buffer<span class="hljs-selector-attr">[ADC_BUFFER_SIZE]</span>;<br><br>void <span class="hljs-built_in">DMA_Config</span>() &#123;<br>    <span class="hljs-comment">// 配置DMA源地址为ADC数据寄存器</span><br>    <span class="hljs-built_in">DMA_SetSourceAddress</span>(ADC_DATA_REGISTER);<br>    <br>    <span class="hljs-comment">// 配置DMA目标地址为adc_buffer数组的起始地址</span><br>    <span class="hljs-built_in">DMA_SetDestinationAddress</span>(adc_buffer);<br>    <br>    <span class="hljs-comment">// 配置DMA传输大小</span><br>    <span class="hljs-built_in">DMA_SetTransferSize</span>(ADC_BUFFER_SIZE);<br>    <br>    <span class="hljs-comment">// 启用DMA地址自增</span><br>    <span class="hljs-built_in">DMA_EnableAddressIncrement</span>();<br>    <br>    <span class="hljs-comment">// 启动DMA传输</span><br>    <span class="hljs-built_in">DMA_StartTransfer</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在该例子中，DMA从ADC的数据寄存器读取数据，并将其写入到内存数组</strong> <code>adc_buffer</code>中。通过启用地址自增功能，每次传输后目标地址都会自动增加，以便将连续的ADC数据存储到数组中的下一个位置。</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><strong>DMA通过自动化数据传输过程，显著提高了系统效率。地址自增功能是DMA实现高效连续数据传输的关键，它简化了编程复杂度，减少了CPU负载，提高了数据传输的速度和效率。</strong></p>]]></content>
    
    
    <categories>
      
      <category>单片机开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HAL库笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
